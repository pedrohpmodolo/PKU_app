create extension if not exists "vector" with schema "extensions";


create sequence "public"."pku_knowledge_id_seq";

create table "public"."conversations" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "title" text not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."conversations" enable row level security;

create table "public"."feedback" (
    "id" uuid not null default gen_random_uuid(),
    "message" text default 'Required'::text,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."feedback" enable row level security;

create table "public"."foods" (
    "Id" bigint generated by default as identity not null,
    "name" text not null,
    "category" text,
    "protein_g" double precision,
    "carbs_g" double precision,
    "energy_kcal" bigint,
    "fdc_id" integer
);


alter table "public"."foods" enable row level security;

create table "public"."messages" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid,
    "sender" text,
    "content" text,
    "created_at" timestamp with time zone default now()
);


alter table "public"."messages" enable row level security;

create table "public"."pku_knowledge" (
    "id" bigint not null default nextval('pku_knowledge_id_seq'::regclass),
    "source" text,
    "content" text,
    "embedding" extensions.vector(1536)
);


alter table "public"."pku_knowledge" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "name" text,
    "dob" date,
    "gender" text,
    "country" text,
    "weight_kg" numeric,
    "height_cm" numeric,
    "uses_imperial" boolean default false,
    "phe_tolerance_mg" numeric,
    "protein_goal_g" numeric,
    "diagnosis_date" date,
    "metabolic_center" text,
    "diet_type" text,
    "allergies" text[],
    "disliked_ingredients" text[],
    "activity_level" text,
    "daily_calorie_target" numeric,
    "pregnancy_status" boolean,
    "breastfeeding" boolean,
    "formula_type" text,
    "pku_severity" text,
    "needs_visual_aids" boolean default false,
    "language" text default 'en'::text,
    "has_caregiver_access" boolean default false,
    "bmr" numeric,
    "created_at" timestamp with time zone default now()
);


alter table "public"."profiles" enable row level security;

alter sequence "public"."pku_knowledge_id_seq" owned by "public"."pku_knowledge"."id";

CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id);

CREATE UNIQUE INDEX feedback_pkey ON public.feedback USING btree (id);

CREATE UNIQUE INDEX foods_fdc_id_key ON public.foods USING btree (fdc_id);

CREATE UNIQUE INDEX foods_pkey ON public.foods USING btree ("Id", name);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX pku_knowledge_pkey ON public.pku_knowledge USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

alter table "public"."conversations" add constraint "conversations_pkey" PRIMARY KEY using index "conversations_pkey";

alter table "public"."feedback" add constraint "feedback_pkey" PRIMARY KEY using index "feedback_pkey";

alter table "public"."foods" add constraint "foods_pkey" PRIMARY KEY using index "foods_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."pku_knowledge" add constraint "pku_knowledge_pkey" PRIMARY KEY using index "pku_knowledge_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."conversations" add constraint "conversations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."conversations" validate constraint "conversations_user_id_fkey";

alter table "public"."foods" add constraint "foods_fdc_id_key" UNIQUE using index "foods_fdc_id_key";

alter table "public"."messages" add constraint "messages_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE not valid;

alter table "public"."messages" validate constraint "messages_conversation_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  meta jsonb;
begin
  meta := new.raw_user_meta_data;

  -- Insert a default profile using metadata fields
  insert into public.profiles (id, name, dob, country)
  values (
    new.id,
    meta->>'name',
    (meta->>'dob')::date,
    meta->>'country'
  );
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.match_pku_documents(query_embedding extensions.vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(id bigint, source text, content text, similarity double precision)
 LANGUAGE sql
 STABLE
 SET search_path TO 'public', 'extensions'
AS $function$
  SELECT
    pku_knowledge.id,
    pku_knowledge.source,
    pku_knowledge.content,
    1 - (pku_knowledge.embedding <=> query_embedding) AS similarity
  FROM pku_knowledge
  WHERE 1 - (pku_knowledge.embedding <=> query_embedding) > match_threshold
  ORDER BY similarity DESC
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.search_foods(search_term text)
 RETURNS TABLE(name text, category text, protein_g real, carbs_g real, energy_kcal real)
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        f.name,
        f.category,
        f.protein_g::real,   -- Cast to REAL
        f.carbs_g::real,     -- Cast to REAL
        f.energy_kcal::real  -- Cast to REAL
    FROM
        foods AS f
    WHERE
        f.name ILIKE '%' || search_term || '%'
    ORDER BY
        LENGTH(f.name)
    LIMIT 5;
END;
$function$
;

create policy "Users can create conversations"
on "public"."conversations"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can delete their conversations"
on "public"."conversations"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can update their conversations"
on "public"."conversations"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can view their conversations"
on "public"."conversations"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Allow public insert"
on "public"."feedback"
as permissive
for insert
to public
with check (true);


create policy "Allow public read access to foods"
on "public"."foods"
as permissive
for select
to public
using (true);


create policy "Can insert messages into own conversations"
on "public"."messages"
as permissive
for insert
to public
with check ((conversation_id IN ( SELECT conversations.id
   FROM conversations
  WHERE (conversations.user_id = auth.uid()))));


create policy "Can view messages in own conversations"
on "public"."messages"
as permissive
for select
to public
using ((conversation_id IN ( SELECT conversations.id
   FROM conversations
  WHERE (conversations.user_id = auth.uid()))));


create policy "Allow public read access to knowledge base"
on "public"."pku_knowledge"
as permissive
for select
to public
using (true);


create policy "Users can insert their profile"
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can read their profile"
on "public"."profiles"
as permissive
for select
to public
using ((auth.uid() = id));


create policy "Users can update their profile"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));



